#### 一些方法相关的实践

- 深拷贝

  ```js
  const isObj = (obj)=>{
    return typeof obj==="object"&& obj!==null
  }
  const deepClone = (obj,map=new Map())=>{
    if(!isObj(obj)){
      return obj
    }
    const target = Array.isArray(obj)?[]:{}
    map[obj]=obj
    for (const i in obj){
      if(map.has(obj[i])){
        target[i] = cacheMap[obj[i]]
      }else{
        target[i] = deepClone(obj[i],map)
      }
    }
    return target
  }
  ```

- debounce

  ```js
  const debounce = (fn, time){
    let timer
    return (...args)=>{
      if(timer){
        clearTimeout(timer)
      }else{
        timer = setTimeout(()=>{
          fn.call(this,...args)
        },time)
      }
    }
  }
  ```

- throttle

  ```js
  const throttle = (fn,time){
    let timer
    return (...args)=>{
      if(timer){
        return
      }else{
        timer = setTimeout(()=>{
          fn.call(this,...args)
          clearTimeout(timer)
        },time)
      }
    }
  }
  ```

- 柯里化

  ```js
  const curry = (fn,...args)=>{
    return fn.length>args.length?(...arguments)=>curry(fn,...args,...arguments):fn(...args)
  }
  ```

- 数组打平

  ```js
  Array.prototype.flat = [].concat(this.map(i=>Array.isArray(i)?i.flat():[i]))
  ```

- Object.prototype.map

  ```js
  Object.prototype.map = (fn)=>{
    if(typeof !== "function"){
      throw("callback is not a function")
    }
    return JSON.parse(JSON.stringfly(this,(k,v)=>{
      if(k){
        return fn.call(this,k,v)
      }
    }))
  }
  ```

  