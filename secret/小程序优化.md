微信小程序的优化方案：

主要分两个方面：
## 1、启动性能
#### 启动概念定义定义
定义： 「用户打开小程序」为起点，到小程序「首页渲染完成」为止。首次onReady完成  
打开率/到达率： 流失率 = 1 - 打开率。		

#### 优化场景分析
启动耗时越长，白屏时间越久，用户越可能因为失去耐心而退出小程序，打开率也会越低；用户等待意愿：用户等待意愿越强，等待时间也会更久，在启动耗时一致的情况下，打开率也会越高。用户等待意愿与使用小程序的场景有关，例如：

- 扫码、搜索等用户目的性较强的场景，通常等待意愿也更强； 
- 广告类的场景下，用户等待意愿较低，要获得较高的打开率，启动性能优化会更加有必要。

#### 小程序启动流程
小程序启动的各流程不是串行的，会尽可能的并行。计算耗时不能简单加和。
小程序启动的各流程不是每次启动都完整进行的，会尽可能的利用缓存。
##### 1、资源准备
###### 1.1 小程序相关信息准备
- 同步请求： 
  （1）首次请求
  （2）同步更新（微信后台会定期检查经常使用的小程序是否更新， 如果启动时已知有新版本，则会同步更新信息）
  （3）强制更新 （用户长时间未使用小程序， 为了保证信息的实时性，会强制同步更新信息）
- 异步请求：
  （1）异步更新：已使用过的小程序，定期检查未发现小程序有新版本，则优先使用本地缓存的信息完成启动，并异步进行更新
###### 1.2 运行环境准备
小程序的运行环境包括小程序进程、客户端原生部分的系统组件和 UI 元素（如 导航栏、tabBar 等）、渲染页面使用的 WebView 容器、开发者 JavaScript 代码的运行环境、小程序基础库等等。

这部分耗时相对耗时较长，耗时长短与平台、设备性能、预加载比例有关；如果没有启动时没有命中预加载的环境
###### 1.3 代码包准备
- 同步下载
  会阻塞小程序的启动流程，影响小程序的启动耗时
  （1）首次下载， 客户端没有缓存，需要同步下载代码包
  （2）同步下载， 检测小程序更新
- 异步下载
  与启动流程并行，不影响启动耗时

  优化方式：
  1、代码包压缩；2、增量更新，让小程序不用下载全量代码包；3、更高效的网络协议；4、预先建立连接；
    
  下载耗时是启动耗时中的重要瓶颈，在用户首次访问小程序或小程序版本更新时，代码包的下载会对启动耗时造成影响。耗时长短与网络环境，代码包压缩后大小，以及是否命中增量更新有关。
##### 2、小程序代码注入（逻辑层）、（视图层）
视图层和逻辑层的小程序代码注入是并行进行的。


##### 3、首页（初次）渲染、首屏内容展示
小程序框架层面，以 Page.onReady 事件触发标志小程序启动过程完成。

首页渲染耗时是启动过程的最后一环，直接影响小程序的启动耗时。耗时长短与页面结构复杂度、参与渲染的自定义组件数量有关。
但是如果首页的主体内容依赖网络请求（例如 wx.request）等异步来源，用户并不一定能立刻看的有意义的完整界面，可能看到的仍然是白屏界面。需要等待网络请求异步返回后，调用 setData 进行页面更新，才能呈现真正的页面。

通常情况下，开发者也会选择先展示「骨架屏」来避免白屏，以优化用户体验。


#### 启动性能优化方式： 
下面罗列了小程序启动优化的方式
##### 1、代码包体积优化
一、合理使用分包加载
使用 分包加载 是优化小程序启动耗时效果最明显的手段。
分包的优点：
1、承载更多功能 2、降低代码包下载耗时 3、降低小程序代码注入耗时  4、降低页面渲染耗时  5、降低内存占用

进一步优化启动耗时
1、独立分包（功能不是很复杂且相对独立、但对启动性能有很高的要求，独立于主包和其他分包运行。从独立分包页面进入小程序时，不需要下载主包。建议开发者将部分对启动性能要求很高的页面放到特殊的独立分包中）
2、分包预加载（分包预下载便是为了解决首次进入分包页面时的延迟问题而设计的。）
3、分包异步化（这使得本来只能放在主包内页面的部分组件和代码逻辑可以剥离到分包中，并在运行时异步加载，从而进一步降低启动所需的包大小和代码量。分包异步化也能有效解决主包大小过度膨胀的问题。）

二、避免非必要的全局定义组件和插件
在 app.json 中通过 usingComponents 全局引用的自定义组件和通过 plugins 全局引入的插件，会包含在小程序的主包中，增加主包的包大小。

1、如果自定义组件只在某个分包的页面中使用，应定义在页面的配置文件中
2、如果插件只在某个分包的中使用，请仅在分包中引用插件

三、 控制代码包内的资源文件
1、代码包内的图片一般应只包含一些体积较小的图标，避免在代码包中包含或在 WXSS 中使用 base64 内联过多、过大的图片等资源文件。这类文件应尽可能部署到 CDN，并使用 URL 引入。

四、及时清理无用代码和资源
将工程目录下所有文件都打入代码包内。意外引入的第三方库、版本迭代中被废弃的代码或依赖、产品环境不需要的测试代码、未使用的组件、插件、扩展库；
##### 2、代码注入优化
一、使用按需注入
在打开上述「按需注入」特性的前提下，可以通过「用时注入」特性使一部分自定义组件不在启动时注入，而是在真正被渲染时才进行注入，进一步降低小程序的启动和首屏时间。

二、使用用时注入
自定义组件不在启动时注入，而是在真正被渲染时才进行注入，进一步降低小程序的启动和首屏时间。涉及占位组件问题。

三、启动过程中减少同步 API 的调用  
四、避免启动过程进行复杂运算
##### 3、首屏渲染优化
1、使用按需注入和用时注入
2、启用初始化缓存
3、避免引用未使用的自定义组件
4、精简首屏数据
5、缓存请求数据
6、骨架屏

## 2、运行时性能

#### 1、合理使用setData
1、data应只包含渲染相关的数据
2、控制setData的频率
3、选择合适的setData范围，比如将像倒计时的setData放到组件内部去处理

#### 2、渲染性能优化
1、适当监听页面、组件的scroll事件
2、选择高性能的动画实现方式
避免通过连续setData改变界面的形式来实现动画
3、使用IntersectionObserver监听元素曝光（避免使用onPageScroll事件， 欠着可以推断某些节点是否可见、有多大比例可见）
4、控制节点数量和层级
5、控制在 Page 构造时传入的自定义数据量

#### 3、页面切换优化
1、避免在 onHide/onUnload 执行耗时操作
2、首屏渲染优化
3、提前发起数据请求

#### 4、控制资源加载
1、控制图片资源的大小
2、避免滥用 image 组件的 widthFix/heightFix 模式

#### 5、内存优化
1、合理使用分包加载
2、使用按需注入和用时注入
3、内存分析
4、处理内存告警
5、小程序常见的内存泄露问题