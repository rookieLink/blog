#### 如何实现前端埋点监控

https://juejin.cn/post/6936562262480158728

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0c508c2fb5434f4891d4edc2e9f2e44f~tplv-k3u1fbpfcp-watermark.awebp)

客户端任务主要有两个

1. 日志采集
2. 日志上报

后端任务

1. 日志接收处理

云上大数据平台

...

#### 1. 日志采集

##### 1.1 稳定性方面

###### 1.1.1 脚本错误

脚本错误主要有两类: 语法错误，运行时错误，主要监控方式有以下几种:

```js
try-catch
window.onerror
window.addEventListener('error'，()=>{})
window.addEventListener('unhandledrejection'()=>{})

```

onerror主要用于捕获预料之外的错误，而try-catch则可以用在预知情况下监控特定错误。两种方式结合使用更加高效。

使用window.onerror捕获JS运行时错误，使用window.addEventListener("unhandlereject")来捕获未处理的promise reject错误，window.addEventListener("error")捕获资源加载错误。但它也能捕获js运行时错误，为避免重复上报js运行时错误，此时只有event.srcElement可以具体判断下错误类型。

Try-catch捕获有两个问题

1. try中的代码出现了语法错误，则无法正常执行catch中的代码
2. try中代码是异步代码，出错了则也无法正常执行catch中的代码，也无法捕获。
3. 以上两种后果如何避免      

###### 1.1.2 接口异常

通过重写XMLHttpRequest和fetch的原生方法来实现

或者写一个拦截器，在拦截器中添加错误上传代码。

###### 1.1.3 资源异常

资源异常: 页面内的图片,css，js等Assets资源加载失败，在捕获类型error事件里是可以拿到资源加载失败的回调的。

###### 1.1.4 白屏

白屏: 页面加载过程中因为任意问题导致渲染没有完成,呈现的空白页面异常。

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fea566f6d50e441a8e89bc5ae2a26eca~tplv-k3u1fbpfcp-watermark.awebp)

###### 1.1.5 Crash

Crash: 页面因为内存溢出，死循环等原因导致的异常崩溃

![img](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2a6c060d206e45cc909e15d7d1763997~tplv-k3u1fbpfcp-watermark.awebp)

##### 1.2 流畅性

###### 1.2.1 页面加载速度

![img](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/80f8886e3aa34334a0908da6b4a3d090~tplv-k3u1fbpfcp-watermark.awebp)

以上指标为一些通用性能表示指标，但不一定能很好的表示页面性能，此时可以自定义一些指标来衡量

![img](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e10d8a769149485d9792cc5c62e6912c~tplv-k3u1fbpfcp-watermark.awebp)

以下是一些用户在使用过程中与流畅性/操作流畅性相关的四个指标评价标准

![img](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7422150cedb2462faca9dd2e16194dc0~tplv-k3u1fbpfcp-watermark.awebp)

###### 1.2.2 响应速度

响应速度: 从用户操作到页面响应的耗时，通常要求小于100ms

基于PerformanceEventTiming 监听用户的任意输入(如click,touchmove)到浏览器给出响应的延迟时间

```js
var observer = new PerformanceObserver(function(list){list.getEntries().forEach(entry =>{
//name: entry.name
//整体耗时: entry.duration
//事件处理函数耗时: entry.processingEnd - entry.processingStart)
});
observer.observe({type: "event", buffered: true});

```

###### 1.2.3 动画流畅性

大概通过requestAnimationFrame可以实现埋点上报

###### 1.2.4 卡顿

卡顿: 页面整个生命周期中，主线程持续执行某一个任务耗时大于50ms

浏览器事件队列机制决定，要实现小于100毫秒的响应，应用必须在没50ms内将控制权返回给主线程

performanceLongTask提供了检测卡顿的能力，可以检测到浏览器内核主线程卡顿时间超过50ms的异常:

```js
var observer = new Performanceobserver(function(list) {
list.getEntries().forEach(entry => {
//开时时间: entry.startTime
//持续时间: entry.duration
}
});
observer.observe({type: "longtask", buffered: true});

```

##### 1.3 用户行为回收

首先是要确定哪些行为需要采集？我们站在用户的立场去考虑一个单页应用的浏览周期内的可能流程：进入应用首页——加载页面内容——浏览页面内容——用户交互（鼠标交互/键盘交互等）——跳转到新页面……

要将用户行为串联成完整的行为链来为js error提供上下文，我们需要知道什么时间，什么位置，发生了什么事情。由此，以上用户浏览过程中的所有的页面行为（包括但不仅限于用户交互）可以用以下几类来大致概括：Api请求，鼠标事件，键盘事件，路由跳转，error 等。

在以上几类中，Api请求，error 在前面已经讲了监控的方法，所以下面整理一下鼠标、键盘以及路由跳转事件的监控记录

我们可以在顶层的document上全面监听各类用户交互事件，如click,keypress,mousemove,scroll等等。但是这种方法也有一个明显的缺陷，假设用户监听了某个dom上的click事件，并且设置了event.stopPropagation()，这种情况的点击事件是无法被document监听到的，而往往这类行为对于错误诊断和业务分析都尤为重要。解决方法是在addEventListener中埋入钩子。

```js
var bhEventHandler = function(){
  //记录用户行为
}
document.addEventListener('click', bhEventHandler, false);
var types = ['EventTarget', 'Node'];
for (var i = 0; i < types.length; i++) {
    var type = types[i];
    var proto = window[type] && window[type].prototype;
    reWrite(proto.addEventListener, function (orig) {
        //重写addEventListener，记录用户行为
    });
}

```

路由跳转无疑会触发浏览器历史记录的改变，每当处于激活状态的历史记录条目发生变化时，window的popstate事件会触发，但是调用history.pushState()或者history.replaceState()不会触发popstate事件。因此路由跳转的监控可以分为两个方面，一方面在window. onpopstate中埋入钩子，另一方面在history.pushState和history.replaceState中埋入钩子。

```js
var origPopstate = window.onpopstate;
window.onpopstate = function () {
    //记录路由行为    
    if (origPopstate) {
        return origPopstate.apply(this, args);
    }
};
var dosomething = function (orig) {
    return function (...args) {
        //记录路由行为    
        return orig.apply(this, args);
    };
};
reWrite(window.history.pushState, dosomething);
reWrite(window.history.replaceState, dosomething);

```

