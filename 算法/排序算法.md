## 排序算法：
### -衡量排序算法的执行效率:
#### 1、最好情况、最坏情况、平均情况时间复杂度
#### 2、时间复杂度的系数、常数、低阶
数据规模很小的时候，也要讲这些考虑进来
#### 3、比较次数和交换（移动）次数
  
### -几个重要概念：
#### 排序算法的内存消耗
涉及概念：原地排序，特指空间复杂度为O(1)的排序算法
#### 排序算法的稳定性
稳定性的概念：遇到相同的排序算法的的时候，如果前后一样，则不发生交换，这种叫做稳定的排序算法  
这里加上个人理解：排序条件的权重值越大的时候，越将条件在后面使用  
示例情况：  
- 1、对手机号进行排序，或者说对数值，单词进行排序
- 2、对订单进行排序，按照金额排序，金额相同按照下单时间排序。遇到这种情况，则可以先对订单进行时间排序，然后再按照金额进行排序，这样，金额相同的两个对象在排序之后的前后顺序不变

### 根据时间复杂度分为3类：

#### 一、O(n^2)
##### 1、冒泡排序
思想：每循环一次，将最大（最小）的数值冒到列表尾端，原地排序
```javascript

// 插入排序，a表示数组，n表示数组大小
public void insertionSort(int[] a, int n) {
  if (n <= 1) return;

  for (int i = 1; i < n; ++i) {
    int value = a[i];
    int j = i - 1;
    // 查找插入的位置
    for (; j >= 0; --j) {
      if (a[j] > value) {
        a[j+1] = a[j];  // 数据移动
      } else {
        break;
      }
    }
    a[j+1] = value; // 插入数据
  }
}
```

##### 2、插入排序
思想：无序区取数据放到有序区，发生插入则移动数组后续位置，相比冒泡排序，少了一些数据交换操作
```javascript
冒泡排序中数据的交换操作：
if (a[j] > a[j+1]) { // 交换
   int tmp = a[j];
   a[j] = a[j+1];
   a[j+1] = tmp;
   flag = true;
}

插入排序中数据的移动操作：
if (a[j] > value) {
  a[j+1] = a[j];  // 数据移动
} else {
  break;
}
```

##### 3、选择排序
思想：创建新数组，每次比较出来原数组中最大的一个，放到新数组中

### 二、O(nlogn)
思考：如何在O(n)的时间复杂度内查找一个无序数组中的第K大元素（使用快速排序）
#### 1、归并排序

```javascript

// 归并排序算法, A是数组，n表示数组大小
merge_sort(A, n) {
  merge_sort_c(A, 0, n-1)
}

// 递归调用函数
merge_sort_c(A, p, r) {
  // 递归终止条件
  if p >= r  then return

  // 取p到r之间的中间位置q
  q = (p+r) / 2
  // 分治递归
  merge_sort_c(A, p, q)
  merge_sort_c(A, q+1, r)
  // 将A[p...q]和A[q+1...r]合并为A[p...r]
  merge(A[p...r], A[p...q], A[q+1...r])
}


merge(A[p...r], A[p...q], A[q+1...r]) {
  var i := p，j := q+1，k := 0 // 初始化变量i, j, k
  var tmp := new array[0...r-p] // 申请一个大小跟A[p...r]一样的临时数组
  while i<=q AND j<=r do {
    if A[i] <= A[j] {
      tmp[k++] = A[i++] // i++等于i:=i+1
    } else {
      tmp[k++] = A[j++]
    }
  }
  
  // 判断哪个子数组中有剩余的数据
  var start := i，end := q
  if j<=r then start := j, end:=r
  
  // 将剩余的数据拷贝到临时数组tmp
  while start <= end do {
    tmp[k++] = A[start++]
  }
  
  // 将tmp中的数组拷贝回A[p...r]
  for i:=0 to r-p do {
    A[p+i] = tmp[i]
  }
}
```

#### 2、快速排序
```javascript

// 快速排序，A是数组，n表示数组的大小
quick_sort(A, n) {
  quick_sort_c(A, 0, n-1)
}
// 快速排序递归函数，p,r为下标
quick_sort_c(A, p, r) {
  if p >= r then return
  
  q = partition(A, p, r) // 获取分区点
  quick_sort_c(A, p, q-1)
  quick_sort_c(A, q+1, r)
}


partition(A, p, r) {
  pivot := A[r]
  i := p
  for j := p to r-1 do {
    if A[j] < pivot {
      swap A[i] with A[j]
      i := i+1
    }
  }
  swap A[i] with A[r]
  return i

```

### 三、O(n)
因为时间复杂度为O(n),所以也把这类算法叫做线性排序

#### 1、桶排序
将数据按阶段分到不同的桶，然后桶内排序，合并桶
#### 2、计数排序
思考高考分数排序的问题，利用一个数组存储在他之前的总数
```javascript

// 计数排序，a是数组，n是数组大小。假设数组中存储的都是非负整数。
public void countingSort(int[] a, int n) {
  if (n <= 1) return;

  // 查找数组中数据的范围
  int max = a[0];
  for (int i = 1; i < n; ++i) {
    if (max < a[i]) {
      max = a[i];
    }
  }

  int[] c = new int[max + 1]; // 申请一个计数数组c，下标大小[0,max]
  for (int i = 0; i <= max; ++i) {
    c[i] = 0;
  }

  // 计算每个元素的个数，放入c中
  for (int i = 0; i < n; ++i) {
    c[a[i]]++;
  }

  // 依次累加
  for (int i = 1; i <= max; ++i) {
    c[i] = c[i-1] + c[i];
  }

  // 临时数组r，存储排序之后的结果
  int[] r = new int[n];
  // 计算排序的关键步骤，有点难理解
  for (int i = n - 1; i >= 0; --i) {
    int index = c[a[i]]-1;
    r[index] = a[i];
    c[a[i]]--;
  }

  // 将结果拷贝给a数组
  for (int i = 0; i < n; ++i) {
    a[i] = r[i];
  }
}
```
#### 3、基数排序
比如对10万个手机号码进行排序

### 二叉搜索树排序

### 堆排序
- 堆是一个完全二叉树
- 堆中每一个节点的值都必须大于等于（或小于等于）其子树中每一个节点的值

堆排序：

往堆中插入一个数据的方式，向上互换数据位置：
``` javascript

public class Heap {
  private int[] a; // 数组，从下标1开始存储数据
  private int n;  // 堆可以存储的最大数据个数
  private int count; // 堆中已经存储的数据个数

  public Heap(int capacity) {
    a = new int[capacity + 1];
    n = capacity;
    count = 0;
  }

  public void insert(int data) {
    if (count >= n) return; // 堆满了
    ++count;
    a[count] = data;
    int i = count;
    while (i/2 > 0 && a[i] > a[i/2]) { // 自下往上堆化
      swap(a, i, i/2); // swap()函数作用：交换下标为i和i/2的两个元素
      i = i/2;
    }
  }
 }
 ```

从堆中删除一个数据：将堆的最后一个数据放到删除的位置，然后进行排序放置，否则会造成数组空洞
```javascript

public void removeMax() {
  if (count == 0) return -1; // 堆中没有数据
  a[1] = a[count];
  --count;
  heapify(a, count, 1);
}

private void heapify(int[] a, int n, int i) { // 自上往下堆化
  while (true) {
    int maxPos = i;
    if (i*2 <= n && a[i] < a[i*2]) maxPos = i*2;
    if (i*2+1 <= n && a[maxPos] < a[i*2+1]) maxPos = i*2+1;
    if (maxPos == i) break;
    swap(a, i, maxPos);
    i = maxPos;
  }
}
```

堆排序分为两个过程：
1、建堆  2、排序

建堆算法：
``` javascript

private static void buildHeap(int[] a, int n) {
  for (int i = n/2; i >= 1; --i) {
    heapify(a, n, i);
  }
}

private static void heapify(int[] a, int n, int i) {
  while (true) {
    int maxPos = i;
    if (i*2 <= n && a[i] < a[i*2]) maxPos = i*2;
    if (i*2+1 <= n && a[maxPos] < a[i*2+1]) maxPos = i*2+1;
    if (maxPos == i) break;
    swap(a, i, maxPos);
    i = maxPos;
  }
}
```
在这段代码中，我们对下标从 2n​ 开始到 1 的数据进行堆化，下标是 2n​+1 到 n 的节点是叶子节点，我们不需要堆化。实际上，对于完全二叉树来说，下标从 2n​+1 到 n 的节点都是叶子节点。

排序：
每次取出堆顶的数据，然后进行上述类似删除算法，对堆进行重新建堆：
``` javascript

// n表示数据的个数，数组a中的数据从下标1到n的位置。
public static void sort(int[] a, int n) {
  buildHeap(a, n);
  int k = n;
  while (k > 1) {
    swap(a, 1, k);
    --k;
    heapify(a, k, 1);
  }
}
```

为什么不用堆排序，而选择快速排序呢？
- 1、堆排序的数据访问没有快速排序友好（对于堆排序，数据是跳着访问的，对于CPU缓存来讲不是很友好）
- 2、当数据有序度高的时候，快速排序会很快，而堆排序可能反而会造成无序的情况

对于完全二叉树：从n/2+1的节点开始，都是叶子结点，这个结论是怎么推出来的呢？
其实这里可以采用反证法，如果不是子节点，按照原理一则子节点是2*(n/2+1)=n+2，大于了n+1这个数组长度，所以只能是子节点