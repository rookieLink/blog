#### http1.1 存在什么问题

http 1.0 时期请求与响应是串行的，且不能复用TCP连接，及其浪费资源

http 1.1 开启了keep-alive属性可以在一定程度上复用TCP连接了，但是请求响应仍然是串行，这样还是会造成带宽浪费，于是又弄出了个pipline属性，该属性可以在一条TCP连接上并行发送多条数据，但是因为响应时仍然要按序响应，这又引起了队头阻塞这一问题，这个也是http1.1不能真正实现多路复用的最大问题。

#### HTTP2.0 解决了什么

http2.0 基于SPDY

http 2.0 实现了真正意义上的多路复用，使得浏览器对同一个网站只使用一条TCP连接就够了，因为在http2.0中存在流和侦的概念，可以简单理解为一个http请求就对应一个流，每个2进制数据帧都会标识自己属于哪个流，因此再响应数据时无需再按照请求到来的顺序予以响应数据，因此解决了队头阻塞问题。

但是由于采用HTTP2之后，一个网站对应一条TCP连接，当TCP发送数据出现了丢包时，由于超时重传会导致其他数据被阻塞，此时HTTP2效率反而不如HTTP1了，因为HTTP1会启用多个TCP连接，一个丢包阻塞了启用另一个就行了。

Http2 还采用了头部压缩功能，可以减少重复请求头的发送，减少了资源浪费。

HTTP2 还新增了服务端推送功能。

但是HTTP2 仍然没能解决了TCP阻塞情况下如何高效传输数据的问题，因此又出现了HTTP3

#### HTTP3 是什么，解决了什么

由于http2.0没能解决TCP丢包阻塞问题，因此http3使用了UDP协议

Http3 基于google QUIC协议

HTTP3主要新增特性

- 基于UDP协议，彻底解决了丢包阻塞问题，将丢包问题抛给应用层来处理。
- 新增快速连接功能，采用基于会话ID的方式，可以一次握手达到身份验证的目的，减少了TCP握手的性能消耗，有点类似TCP的快速连接。
- 正对网络频繁切换的情况下有更好的性能表现，TCP是基于端口IP等信息来确认一条连接的，如果在频繁切换网络的情况下，会频繁简历新连接，浪费性能，而基于会话ID的HTTP3由于始终带着绘画ID，不管咋么切换网络都能很快确认连接。
- 更强的安全性，对请求头都做了加密处理