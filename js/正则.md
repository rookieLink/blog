正则是对象

正则是一个用来处理字符串的规则：
1、正则只能用来处理字符串
2、处理一般包含两方面：
    （1）验证当前字符串是否符合某个规则“正则匹配”
    （2）把符合规则的字符获取到“正则捕获”
    
学习正则就是在学习如何编写规则，每一个正则就是有“元字符”、“修饰符”组成

创建正则的两种方式
```javascript
let reg1 = /^\d+$/g; // =>字面量
let reg2 = new RegExp("^\\d+$", "g")

```
斜杠之间的部分都是元字符，后面的是修饰符

常用修饰符： i,m,g
i: ignoreCase: 忽视大小写
m: multiline: 多行匹配
g: global   全局匹配

常用的元字符
特殊元字符：
    \d 0-9之间的一个数字
    \D 非0-9之间的任意字符
    \w “数字、字母、下划线”中的任意一个[0-9a-zA-Z_]
    \s 匹配任意一个空白字符（包括\t制表符【tab】键四个空格）
    \b 匹配边界符  'zhang' (z左边和u右边就是边界)
    \n 匹配一个换行符
    \ 转义字符（把一个普通字符转义为特殊字符，例如：\d，把有特殊含义的转换为普通意思）
    .   不仅仅是小数点，代表处理\n以外的任意字符
    ^  以某个元字符开头
    $   以某个元字符结尾
    x|y x或者y中的任意一个
    [xyz] x或者y或者z中的任意一个
    [^xyz] 除了xyz以外的任意字符
    [a-z]  获取a-z中的任意一个字符
    [^a-z] 除了a-z的任意字符
    ()  正则分组
    (?:)    当前分组只匹配不捕获
    (?=)    正向预查
    (?!)    反向预查
量词元字符： 
    *   出现0——多次
    ?   出现0——1次
    +   出现1——多次
    {n} 出现n次
    {n,} 出现n-多次
    {n,m}   出现n-m次
普通元字符：
    只要在正则中出现的元字符（在基于字面量方式创建），除了特殊和有量词
    的意义以外，其余的都是普通元字符

#### []的一些细节
1.中括号中出现的元字符都是代表本身含义
```javascript
let reg = /^.+$/; //=>以任意字符开头，任意字符结尾，设置了^和$，代表含义只能是xxx

let reg1 = /^[.]+$/;    // 这里面.仅代表小数点
```
2.中括号中出现的两位数，不是两位数，而是两个数字中的任意一个
```javascript
let reg = /^[18]$/; // =>1或者8，
let reg1 = /^[12-65]$/; // 1或者2~6或者5

let reg2 = /^([2-5][0-9])|(1[89])|(6[0-5])$/
```

#### ()一些细节
1、改变默认优先级
2、分组捕获
3、分组引用

```javascript
let reg1 = /^(18|19)$/


let reg2 = /^([a-z])([a-z])\2\1$/; 

let reg3 = /^(\d{6})(\d{4})(\d{2})(\d{2})\d{2}(\d)(?:\d|x)$/
reg3.exec('');
// 获取的结果是一个数组，如果不匹配则结果是null
```


## 详解正则捕获
概念：把一个字符串中和正则匹配的部分获取到
[正则]
    exec
    test
 [字符串]
    replace
    split
    match

### 1、exec
如果当前正则和字符串不匹配，结果为null
如果匹配，捕获的结果是一个数组
    第一项是大正则捕获的内容
    index： 是正则捕获的起始索引
    input： 原始操作的字符串
执行一次只能捕获到第一个正则匹配的内容，执行多次，没有作用（！！！正则捕获有懒惰性）

懒惰性： 只能捕获到第一个匹配的内容，剩余默认捕获不到
    reg.lastIndex 正则捕获的时候，下一次在字符串中开始查找的索引，即使手动修改了lastIndex值，依然没有用
    解决方法（唯一方案）： 在正则后面加上修饰符g

```javascript
let str = 'zhang1996feng';
let reg = /\d+/;
reg.exec(str);

// 自主执行多次方法,这个方法等同于  match方法
// 把所有匹配的内容都捕获到，放到一个数组中返回

RegExp.prototype.myExecAll = function(str) {
    // => this:reg, 当前操作的正则，开始捕获，直到捕获不到你内容为止，期间把捕获到的内容存储到数组中
    if (!this.global) {
        return this.exec(str);
    } 
    let result = [],
        valAry = this.exec(str);
    while(valAry) {
        result.push(valAry[0]);
        valAry = this.exec(str);
    }
    return result;
}
```
在正则捕获的时候，如果正则中存在分组，捕获的时候，不仅仅把大正则匹配到的字符捕获到（数字匹配），而且还会把
小分组匹配的内容也单独取出来，（数组中的第二项开始就是小分组捕获的内容）； =》“分组捕获”
(?:)只匹配，不捕获

正则捕获具有贪婪性，总是捕获到正则匹配中最长的内容，解决贪婪性的方法，在量词元字符后面加上?, 
let reg = /^\d+?$/g; 此时代表的不是出现零次到1次了， 而是取消正则捕获的贪婪性

```javascript
let str = "zhang{1996}feng{2020}"
let  reg = /^\{(\d+)\}$/g;
reg.exec(str); // =>  ['{1996}','1996']

reg.match(str); // => ['{1996}','{2020}']  小分组的内容没有捕获到，具有局限性
```
### ?在正则中的作用
1、量词元字符：出现零次或者1次
2、取消贪婪性
3、?:只匹配不捕获
4、?=正向预查
5、?!负向预查


### test
test方法会改变lastIndex的值


注意：虽然捕获的不是同一个字符串，但是是同一个正则进行捕获额，上一次的捕获结果会影响下一次

```javascript
let str = "zhang1996feng2020"
let  reg = /^(\d+)$/g;

console.log(reg.test(str));
console.log(RegExp.$1); // 把上一次匹配到的结果获取到，获取的是第一个小分组匹配的内容，大正则匹配的内容无法获取
// 是全局的值，浏览器中$1只有一个，其他的正则操作也会覆盖这个值，所以这种方式没啥用

```
