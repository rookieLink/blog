this:
    当前方法执行的主体（谁执行的方法，this就是谁）
    所以，this和当前方法在哪创建和执行都没有必然关系
    
1、给当前某个事件绑定方法
    方法中的this都是当前操作的元素本身
    
2、函数执行
    看函数前面是否有点，有的话，点前面是谁，this就是谁，没有点则this指向windows（严格模式下是undefined）
    
3、构造函数执行
    方法中的this一般都是当前类的实例
    
4、箭头函数
    箭头函数中没有this，this是上下文中的this
    
5、在小括号表达式中，会影响this指向
```javascript
let obj = {
    fn:function() {
      console.log(this);
    }
}
obj.fn();   // => obj
(10, obj.fn)();   // => window
```

6、使用call、apply、bind
改变this指向， 非严格模式下，第一个参数不写或者写null、undefined都是window， 严格模式下，写谁就是谁，不写是undefined

### 函数调用时：
this是一个复杂的机制，javascript标准定义了[[thisMode]]私有属性
[[thisMode]]有三个取值：
lexical： 表示从上下文中找this，这对应了箭头函数
global： 表示当this为undefined时，取全局对象，对应了普通函数
strict：当严格模式时使用，this严格按照调用时传入的值，可能为null或者undefined

方法行为跟普通函数有差异，就是因为class设计成了默认按strict模式执行

```javascript

    class C {
        showThis() {
            console.log(this);
        }
    }
    var o = new C();
    var showThis = o.showThis;

    showThis(); // undefined
    o.showThis(); // o
```