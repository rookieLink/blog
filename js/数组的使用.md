### 数组的使用


可以用slice方法进行数组克隆

### length属性
代表数组的长度，可以通过对数组的length进行修改来删除数组末尾内容
```javascript
// 减小数组长度
var a = [1,2,3,4,5];
a.length--;
console.log(a); // => [1,2,3,4];

// 如果增加数组长度，会增加一项空的项
// 自行尝试
```

数组的使用从四个维度来进行考虑记忆：
- 1、方法的作用
- 2、方法的参数
- 3、方法的返回值
- 4、原数组是否改变

### push
- 1、向数组末尾新增内容（可以有多个参数）
- 2、需要新增的内容
- 3、返回新增后原数组长度
- 4、原数组改变

### pop
- 1、删除数组末尾元素
- 2、没有参数
- 3、返回删除前原数组长度
- 4、原数组改变

### unshift()
和push方法类似， 会改变数组后续内容索引，影响效率
- 1、向数组开头新增内容（可以有多个参数）
- 2、需要新增的内容
- 3、返回新增后原数组长度
- 4、原数组改变

### shift
和pop方法类似， 会改变数组后续内容索引，影响效率
- 1、删除数组开头元素
- 2、没有参数
- 3、返回删除前原数组长度
- 4、原数组改变

### slice
- 1、截取数组的内容
- 2、第一个参数是开始位置，第二个是结束位置，参数可以为负数
- 3、返回新数组，内容为截取的内容
- 4、原数组不改变

### splice
- 1、删除、修改、新增数组的内容
- 2、第一个参数是开始位置，第二个是结束位置，第三个参数是替换截取掉的内容
- 3、返回新数组，内容为截取的内容
- 4、原数组改变

### indexOf
- 1、从数组中查询第一个满足条件的值
- 2、具体需要匹配的值
- 3、返回满足条件的值的索引，如果没有该值，则返回-1
- 4、原数组不改变

### includes
效果和 indexOf(x) >=0 类似，但是includes可以判断NaN；
```javascript
[NaN].includes(NaN); // => true

[NaN].indexOf(NaN); // => false
```

### lastIndexOf
- 1、从数组中查询最后一个满足条件的值
- 2、具体需要匹配的值
- 3、返回满足条件的值的索引，如果没有该值，则返回-1
- 4、原数组不改变

### find
- 1、从数组中查询第一个满足条件的值
- 2、一个返回布尔值的函数
- 3、返回满足条件的值，如果没有该值，则返回undefined
- 4、原数组不改变

### findIndex
经常会用这个函数去进行判断是否存在满足条件的值
- 1、从数组中查询第一个满足条件的值的索引
- 2、一个返回布尔值的函数
- 3、返回满足条件的值的索引，如果没有该值，则返回 -1
- 4、原数组不改变

### concat
- 1、将更多内容拼接到数组中
- 2、需要拼接的值（值可以是数组和具体值， 会把数组中的具体值取出来进行拼接）
- 3、返回拼接后的原数组
- 4、原数组改变
```javascript
let a = [1,2,3];
a.concat(4,[5,6,[7,8]]);
console.log(a); // => [1,2,3,4,5,6,[7,8]]
// 如果不想影响原数组可以用下面这种方式
[].concat(a,4,[5,6,[7,8]]);
```

### join
- 1、将数组内容拼接为一个字符串
- 2、参数为连接的内容，默认为','
- 3、返回拼接的字符串
- 4、原数组不改变
```javascript
a = [1, 2, 3, 4];
a.join(); // => '1,2,3,4'
a.join('+'); // => '1+2+3+4'
```

### reverse
- 1、将数组内容反转
- 2、没有参数
- 3、返回反转后的原数组
- 4、原数组改变
```javascript
// 使用方式，将一个字符串反转要怎么做
// 最简单的方式
let str = 'zhangfeng';
str.split('').reverse().join(''); // => 'gnefgnahz'
```

### sort
- 1、将数组内容进行排序
- 2、可以没有参数，也可以是个函数，注意不传参的时候，11 会排在 2之前
- 3、排序后的原数组
- 4、原数组改变
>传递函数参数的情况不再赘述，自行理解


### keys、values、entries
这三个分别数取数组的键、值、键值对，返回结果类型都是Iterator

### forEach
循环遍历数组， 参数是函数（函数的参数分别是：当前项，索引，原数组）

### filter
遍历数组，筛选符合条件的组成一个新数组返回， 参数是函数（函数的参数分别是：当前项，索引，原数组）

### flat
扁平化数组,信息参考：

https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/flat
- 1、遍历数组，将数组中的每个值取出来，如果数组的值还是数组，则继续取出来，放到一个新数组中，并且会移除数组中的空项
- 2、参数默认是1，表示扁平化深度，如果想要无限拉平，则使用Infinity
- 3、扁平化的新数组
- 4、原数组不改变

```javascript
let a = [1, [2,3,[4,5, [6]], {name: 'zhang'}], 7];
a.flat(); // => [1, 2, 3,[4,5,[6]], {name: 'zhang'}, 7]

a.flat(2); // => [1, 2, 3,4,5,[6], {name: 'zhang'}, 7]

[1, ,2].flat(); // => [1,2]
```

### flatMap
某种意义上来讲，和flat类似，只能展开一层数组， 效果等于flat(1);
但是flatMap可以传一个函数参数进去，修改拉平的值，效果相当于flat和Map结合

```javascript
let arr1 = ["it's Sunny in", "", "California"];

arr1.map(x => x.split(" "));
// [["it's","Sunny","in"],[""],["California"]]

arr1.flatMap(x => x.split(" "));
// ["it's","Sunny","in", "", "California"]
```

替代方案, 通过使用reduce和concat：
>请注意，这是低效的，并且应该避免大型阵列：在每次迭代中，它创建一个必须被垃圾收集的新临时数组，
并且它将元素从当前的累加器数组复制到一个新的数组中，而不是将新的元素添加到现有的数组中。
```javascript
var arr = [1, 2, 3, 4];

arr.flatMap(x => [x, x * 2]);
// is equivalent to
arr.reduce((acc, x) => acc.concat([x, x * 2]), []);
// [1, 2, 2, 4, 3, 6, 4, 8]
```

### reduce
对数组中的每个元素执行一个由您提供的reducer函数(升序执行)，将其结果汇总为单个返回值。
参数为： 执行函数，初始值 
函数参数分别为：累计器（也就是上一次的结果），当前值， 当前索引，源数组

>注意：作为第一次调用 callback函数时的第一个参数的值。 如果没有提供初始值，则将使用数组中的第一个元素。 
在没有初始值的空数组上调用 reduce 将报错。

### reduceRight
reduceRight的作用和reduce相同，只不过是从右向左的数组

### some
数组中存在满足条件的就返回true

### every
数组中每一个都满足条件才返回true

### map
将数组每一项进行处理后输出新数组

```javascript
[1,2,3,4].map(item => {return 2*item}); // [2, 4, 6, 8]
```
